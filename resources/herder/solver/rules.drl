package herder.solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;
import herder.solver.types.Event;
import herder.solver.types.HerderSolution;
import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.joda.time.Period

import org.apache.commons.collections.CollectionUtils;

global HardSoftScoreHolder scoreHolder;

rule "spread events out (penalty per extra event in slot)"
    when
        $leftEvent : Event(
                slot != null, $slot: slot,
                $leftId : id)
        $rightEvent : Event(
                slot == $slot,
                id > $leftId)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -10);
end

rule "later events are worse"
    when
        $event : Event(
                slot != null, $slot: slot)
		$solution: HerderSolution(
			$firstDay: firstDay
		)
    then
	scoreHolder.addSoftConstraintMatch(kcontext, $solution);
        //scoreHolder.addSoftConstraintMatch(kcontext, -((Interval)$slot).getStart().getDayOfMonth());
		//-new Period($firstDay, (DateTime)$slot).toStandardMinutes().getMinutes());
end

rule "people shouldn't overlap"
    when
        $leftEvent : Event(
                slot != null, $slot: slot,
                people != null, $people: people,
                $leftId : id)
        $rightEvent : Event(
                slot == $slot,
                CollectionUtils.isNotEmpty(CollectionUtils.intersection(people, $people)),
                id > $leftId)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10);
end

rule "events with people shouldn't have null slots"
    when
        $event : Event(
                slot == null,
                people != null,
                CollectionUtils.isNotEmpty(people))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -15);
end

rule "events without people have null slots"
    when
        $event : Event(
                slot != null,
                people != null,
                CollectionUtils.isEmpty(people))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10);
end

rule "events with preferred slots like those"
    when
        $event : Event(
            CollectionUtils.isNotEmpty(preferredSlots),
            !preferredSlots.contains(slot)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

rule "events with chained events are on later days"
    when
        $event : Event(
            slot != null,
            chainedEvent != null,
            ((Event)chainedEvent).slot != null,
            ((Interval)slot).getStart().toLocalDate() <= ((Interval)((Event)chainedEvent).slot).getStart().toLocalDate()
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end
